# System Design Primer

## CAP Theorem
The CAP theorem states that a distributed system can only provide two of the following three guarantees:
- **Consistency**: Every read receives the most recent write or an error
- **Availability**: Every request receives a response (not guaranteed to be most recent)
- **Partition Tolerance**: The system continues to operate despite network partitions

In practice, partition tolerance is required for distributed systems, so the choice is between CP (Consistency + Partition Tolerance) and AP (Availability + Partition Tolerance) systems.

### CP vs AP Trade-offs
- **CP Systems** (e.g., HBase, MongoDB): Prioritize consistency, may reject requests during partitions
- **AP Systems** (e.g., Cassandra, DynamoDB): Prioritize availability, allow eventual consistency

## Caching
Caching improves performance by storing frequently accessed data in fast memory.

### How Caching Works
1. Check if data exists in cache (cache hit) - return immediately
2. If not in cache (cache miss) - fetch from database
3. Store result in cache for future requests
4. Data expires based on TTL (Time To Live)

### Cache Strategies
- **Write-through**: Write to cache and database simultaneously
- **Write-back**: Write to cache first, sync to database later
- **Write-around**: Write directly to database, cache on read

### Popular Caching Solutions
- Redis: In-memory data store with persistence
- Memcached: Simple distributed memory caching

## SQL vs NoSQL Databases

### SQL (Relational) Databases
- Use structured schema with tables, rows, columns
- Support ACID transactions (Atomicity, Consistency, Isolation, Durability)
- Best for: Complex queries, transactions, relationships
- Examples: PostgreSQL, MySQL, Oracle

### NoSQL Databases
- Flexible schema, various data models
- Often sacrifice ACID for scalability
- Types: Document (MongoDB), Key-Value (Redis), Column (Cassandra), Graph (Neo4j)
- Best for: High scalability, unstructured data, rapid development

### Key Differences
| SQL | NoSQL |
|-----|-------|
| Fixed schema | Dynamic schema |
| Vertical scaling | Horizontal scaling |
| ACID compliant | BASE (eventual consistency) |
| Complex joins | Denormalized data |

## Load Balancing

### What is Load Balancing?
Load balancing distributes incoming traffic across multiple servers to ensure no single server is overwhelmed.

### Load Balancing Algorithms
- **Round Robin**: Requests distributed sequentially to each server
- **Least Connections**: Route to server with fewest active connections
- **Weighted Round Robin**: Servers assigned weights based on capacity
- **IP Hash**: Client IP determines which server handles request
- **Least Response Time**: Route to server with fastest response

### Load Balancer Types
- Layer 4 (Transport): Routes based on IP and port
- Layer 7 (Application): Routes based on content (URL, headers)

## CDN (Content Delivery Network)

### What is a CDN?
A Content Delivery Network is a geographically distributed network of edge servers that cache and deliver content to users from nearby locations.

### How CDN Works
1. User requests content (image, video, static file)
2. Request routed to nearest edge server
3. If cached: Serve from edge (fast)
4. If not cached: Fetch from origin, cache, then serve

### Benefits
- Reduced latency (content closer to users)
- Lower bandwidth costs
- Improved availability and redundancy
- DDoS protection

### Popular CDN Providers
- Cloudflare, AWS CloudFront, Akamai, Fastly

## Distributed Systems Concepts

### Consistency Models
- **Strong Consistency**: All nodes see same data at same time
- **Eventual Consistency**: Updates propagate eventually, temporary inconsistency allowed
- **Causal Consistency**: Operations with causal relationship maintain order

### Replication
- **Master-Slave**: One write node, multiple read replicas
- **Master-Master**: Multiple nodes accept writes
- **Quorum**: Requires majority consensus for operations

### Partitioning (Sharding)
Dividing data across multiple databases to handle scale:
- **Horizontal Partitioning**: Different rows in different tables
- **Vertical Partitioning**: Different columns in different tables
- **Hash-based**: Use hash function to determine partition
- **Range-based**: Partition by ranges of values

## Message Queues

### Purpose
Decouple components, handle async processing, manage traffic spikes.

### Popular Systems
- RabbitMQ, Apache Kafka, AWS SQS, Redis Pub/Sub

### Patterns
- Point-to-Point: One producer, one consumer
- Publish-Subscribe: One producer, multiple consumers

## Microservices Architecture

### Characteristics
- Independent, loosely coupled services
- Each service owns its data
- Communicate via APIs (REST, gRPC)
- Can be deployed and scaled independently

### Benefits
- Scalability: Scale individual services
- Flexibility: Different tech stacks per service
- Resilience: Failure isolation

### Challenges
- Distributed system complexity
- Data consistency across services
- Network latency
- Debugging and monitoring

## System Design Interview Tips

1. **Clarify Requirements**: Ask about scale, features, constraints
2. **Estimate Scale**: Users, requests/second, data volume
3. **High-Level Design**: Draw major components
4. **Deep Dive**: Focus on critical components
5. **Identify Bottlenecks**: Propose solutions
6. **Trade-offs**: Discuss alternatives and their pros/cons
