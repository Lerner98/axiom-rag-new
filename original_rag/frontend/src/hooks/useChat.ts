/**
 * useChat Hook
 * Handles chat interactions with TRUE streaming support (V6).
 * ADR-007: Uses chat-scoped collections (chat_{chatId})
 *
 * V6 TRUE STREAMING:
 * - Real-time phase events: searching → found_sources → generating
 * - Sources emitted BEFORE generation starts
 * - Tokens streamed as they're generated by LLM
 */

import { useCallback } from 'react';
import { useChatStore, Source } from '@/stores/chatStore';
import { streamChat } from '@/lib/sse';
import type { SSEStreamingPhase } from '@/types';

export function useChat() {
  const {
    sessionId,
    chats,
    currentChatId,
    isStreaming,
    currentStreamingMessage,
    currentSources,
    error,
    addUserMessage,
    startStreaming,
    setStreamingPhase,  // V6: For real-time phase updates
    appendStreamToken,
    setSources,
    finishStreaming,
    setError,
    clearMessages,
    resetSession,
  } = useChatStore();

  // Get current chat messages (with null safety for persisted state migration)
  const currentChat = chats?.find((chat) => chat.id === currentChatId);
  const messages = currentChat?.messages ?? [];

  // ADR-007: Collection name is derived from chat ID (chat_{chatId})
  const collectionName = currentChatId ? `chat_${currentChatId}` : null;

  const sendMessage = useCallback(
    async (content: string) => {
      if (!content.trim() || isStreaming || !currentChatId) return;

      // Add user message to state
      addUserMessage(content);

      // Start streaming
      startStreaming();

      try {
        // ADR-007: Pass chatId for scoped endpoint (not collectionName)
        await streamChat(content, sessionId, currentChatId || undefined, {
          // V6 TRUE STREAMING: Handle real-time phase updates
          onPhase: (phase: SSEStreamingPhase) => {
            // Map backend phases to frontend phases
            // Backend sends: 'searching' | 'generating'
            // Frontend expects: 'searching' | 'found_sources' | 'generating'
            // Note: 'found_sources' is set when onSources fires
            if (phase === 'searching') {
              setStreamingPhase('searching');
            } else if (phase === 'generating') {
              setStreamingPhase('generating');
            }
          },
          onToken: (token) => {
            appendStreamToken(token);
          },
          onSources: (sources: Source[]) => {
            // Sources arrive BEFORE generation - this triggers 'found_sources' phase
            setSources(sources);
          },
          onDone: (_messageId, wasGrounded, processingTimeMs) => {
            finishStreaming(wasGrounded, processingTimeMs);
          },
          onError: (err) => {
            setError(err.message);
          },
        });
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred');
      }
    },
    [
      sessionId,
      isStreaming,
      currentChatId,  // ADR-007: Using chatId for scoped endpoint
      addUserMessage,
      startStreaming,
      setStreamingPhase,  // V6: Added for phase updates
      appendStreamToken,
      setSources,
      finishStreaming,
      setError,
    ]
  );

  return {
    // State
    messages,
    isStreaming,
    currentStreamingMessage,
    currentSources,
    error,
    sessionId,
    collectionName,

    // Actions
    sendMessage,
    clearMessages,
    resetSession,
  };
}
